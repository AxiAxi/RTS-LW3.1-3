{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nvar _jsxFileName = \"C:\\\\Users\\\\Aspire\\\\projects\\\\studyAll\\\\RTS\\\\3\\\\AwesomeProject\\\\App.js\";\nimport React, { Component, useState } from 'react';\nimport StyleSheet from \"react-native-web/dist/exports/StyleSheet\";\nimport Text from \"react-native-web/dist/exports/Text\";\nimport View from \"react-native-web/dist/exports/View\";\nimport Button from \"react-native-web/dist/exports/Button\";\nimport Alert from \"react-native-web/dist/exports/Alert\";\nimport TextInput from \"react-native-web/dist/exports/TextInput\";\n\nvar fErmatFactorization = function fErmatFactorization(number) {\n  if (number <= 0 || !Number.isInteger(number)) {\n    return;\n  }\n\n  ;\n\n  if (number % 2 === 0) {\n    return [number / 2, 2];\n  }\n\n  ;\n  var a = Math.ceil(Math.sqrt(number));\n\n  if (Math.pow(a, 2) === number) {\n    return [a, a];\n  }\n\n  ;\n  var b;\n\n  while (true) {\n    var b1 = Math.pow(a, 2) - number;\n    b = Math.sqrt(b1) | 0;\n\n    if (Math.pow(b, 2) === b1) {\n      break;\n    } else {\n      a++;\n    }\n\n    ;\n  }\n\n  ;\n  return [a - b, a + b];\n};\n\nvar P = 4;\nvar POINTS = [{\n  x1: 0,\n  x2: 6,\n  highLowRule: +1\n}, {\n  x1: 1,\n  x2: 5,\n  highLowRule: +1\n}, {\n  x1: 3,\n  x2: 3,\n  highLowRule: -1\n}, {\n  x1: 2,\n  x2: 4,\n  highLowRule: -1\n}];\nvar accuracy = 0;\nvar learningSpeed = .001;\nvar deadlines = {\n  temporal: {\n    isUsed: false,\n    seconds: .5\n  },\n  iterative: {\n    isUsed: true,\n    iterations: 100\n  }\n};\n\nvar outputSignal = function outputSignal(point, w1, w2) {\n  return +(point.x1 * w1 + point.x2 * w2).toFixed(accuracy);\n};\n\nvar highLowCheck = function highLowCheck(point, y, P) {\n  if (point.highLowRule === +1) {\n    return y > P;\n  } else if (point.highLowRule === -1) {\n    return y < P;\n  }\n\n  ;\n};\n\nvar w = function w(_w, deltaRule, x, learningSpeed) {\n  return +(_w + deltaRule * x * learningSpeed).toFixed(accuracy);\n};\n\nvar outputSignalCheck = function outputSignalCheck(points, w1, w2) {\n  var successCounter = 0;\n\n  for (var _iterator = points, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[typeof Symbol === \"function\" ? Symbol.iterator : \"@@iterator\"]();;) {\n    var _ref;\n\n    if (_isArray) {\n      if (_i >= _iterator.length) break;\n      _ref = _iterator[_i++];\n    } else {\n      _i = _iterator.next();\n      if (_i.done) break;\n      _ref = _i.value;\n    }\n\n    var _point = _ref;\n    highLowCheck(_point, outputSignal(_point, w1, w2), P) && successCounter++;\n  }\n\n  ;\n  return successCounter === POINTS.length;\n};\n\nvar perceptronTraining = function perceptronTraining(P, accuracy, learningSpeed) {\n  var paramW1 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n  var paramW2 = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n  var turn = 0;\n  var w1 = paramW1,\n      w2 = paramW2;\n  var deltaRule = 0;\n  var iretationCounter = 0;\n  var performanceStart = performance.now();\n  var performanceEnd;\n\n  while (true) {\n    var point = POINTS[turn];\n    var y = outputSignal(point, w1, w2);\n\n    if (highLowCheck(point, y, P) && outputSignalCheck(POINTS, w1, w2)) {\n      break;\n    }\n\n    ;\n    deltaRule = +(P - y).toFixed(accuracy);\n    w1 = w(w1, deltaRule, point.x1, learningSpeed);\n    w2 = w(w2, deltaRule, point.x2, learningSpeed);\n    turn === POINTS.length - 1 ? turn = 0 : turn++;\n    iretationCounter++;\n\n    if (deadlines.temporal.isUsed) {\n      performanceEnd = performance.now();\n\n      if (performance.now() - performanceStart >= deadlines.temporal.seconds * 1000) {\n        break;\n      }\n\n      ;\n    }\n\n    ;\n\n    if (deadlines.iterative.isUsed) {\n      if (iretationCounter >= deadlines.iterative.iterations) {\n        break;\n      }\n\n      ;\n    }\n\n    ;\n  }\n\n  ;\n  var perceptronPerformanceTime = performanceEnd - performanceStart || 0;\n  return [w1, w2, perceptronPerformanceTime, iretationCounter];\n};\n\nexport default function App() {\n  var _useState = useState(''),\n      _useState2 = _slicedToArray(_useState, 2),\n      factorizedNumber = _useState2[0],\n      setFactorizedNumber = _useState2[1];\n\n  var _useState3 = useState(''),\n      _useState4 = _slicedToArray(_useState3, 2),\n      factorizedNumberAnswer = _useState4[0],\n      setFactorizedNumberAnswer = _useState4[1];\n\n  return React.createElement(View, {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 114\n    }\n  }, React.createElement(Text, {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 115\n    }\n  }, \"Fermat's Factorization Method\"), React.createElement(Text, {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 116\n    }\n  }, \"A  *  B  =  \" + (factorizedNumber || '')), React.createElement(TextInput, {\n    placeholder: \"Set Number\",\n    onChangeText: function onChangeText(text) {\n      return setFactorizedNumber(text);\n    },\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 117\n    }\n  }), React.createElement(Button, {\n    title: \"Number Factorization\",\n    onPress: function onPress() {\n      return setFactorizedNumberAnswer(fErmatFactorization(+factorizedNumber));\n    },\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 118\n    }\n  }), React.createElement(Text, {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 119\n    }\n  }, factorizedNumberAnswer && \"A  =  \" + factorizedNumberAnswer[0] + \";  B  =  \" + factorizedNumberAnswer[1]), React.createElement(Text, {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 122\n    }\n  }, \"Perceptron Model\"));\n}\n;\nvar styles = StyleSheet.create({\n  container: {\n    flex: 1,\n    justifyContent: 'center',\n    alignItems: 'center',\n    backgroundColor: '#F5FCFF'\n  }\n});","map":{"version":3,"sources":["C:/Users/Aspire/projects/studyAll/RTS/3/AwesomeProject/App.js"],"names":["React","Component","useState","fErmatFactorization","number","Number","isInteger","a","Math","ceil","sqrt","b","b1","P","POINTS","x1","x2","highLowRule","accuracy","learningSpeed","deadlines","temporal","isUsed","seconds","iterative","iterations","outputSignal","point","w1","w2","toFixed","highLowCheck","y","w","deltaRule","x","outputSignalCheck","points","successCounter","length","perceptronTraining","paramW1","paramW2","turn","iretationCounter","performanceStart","performance","now","performanceEnd","perceptronPerformanceTime","App","factorizedNumber","setFactorizedNumber","factorizedNumberAnswer","setFactorizedNumberAnswer","text","styles","StyleSheet","create","container","flex","justifyContent","alignItems","backgroundColor"],"mappings":"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","sourcesContent":["import React, { Component, useState } from 'react';\nimport { StyleSheet, Text, View, Button, Alert, TextInput } from 'react-native';\n\nconst fErmatFactorization = number => {\n    \n  if ((number <= 0) || !(Number.isInteger(number))) {\n      return;\n  };\n  \n  if ((number % 2) === 0) {\n      return [number / 2, 2];\n  };\n  \n  let a = Math.ceil(Math.sqrt(number));\n  \n  if (a**2 === number) {\n      return [a, a];\n  };\n  \n  let b;\n  \n  while (true) {\n      let b1 = a**2 - number;\n      \n      b = Math.sqrt(b1) | 0;\n      \n      if (b**2 === b1) {\n          break;\n      } else {\n          a++;\n      };\n  };\n  \n  return [a - b, a + b];\n};\n\n\nconst P = 4;\n\nconst POINTS = [\n    {x1: 0, x2: 6, highLowRule: +1},\n    {x1: 1, x2: 5, highLowRule: +1},\n    {x1: 3, x2: 3, highLowRule: -1},\n    {x1: 2, x2: 4, highLowRule: -1}\n];\n\nconst accuracy = 0;\n\nconst learningSpeed = .001;\n\nconst deadlines = {\n    temporal: {isUsed: false, seconds: .5},\n    iterative: {isUsed: true, iterations: 100}\n};\n\nconst outputSignal = (point, w1, w2) => +(point.x1 * w1 + point.x2 * w2).toFixed(accuracy);\n\nconst highLowCheck = (point, y, P) => {\n    if (point.highLowRule === +1) {\n        return y > P;\n    } else if (point.highLowRule === -1) {\n        return y < P;\n    };\n};\n\nconst w = (w, deltaRule, x, learningSpeed) => +(w + deltaRule * x * learningSpeed).toFixed(accuracy);\n\nconst outputSignalCheck = (points, w1, w2) => {\n    let successCounter = 0;\n    for (const point of points) {\n        highLowCheck(point, outputSignal(point, w1, w2), P) && successCounter++;\n    };\n    return successCounter === POINTS.length;\n};\n\nconst perceptronTraining = (P, accuracy, learningSpeed, paramW1 = 0, paramW2 = 0) => {\n    let turn = 0;\n    let w1 = paramW1, w2 = paramW2;\n    let deltaRule = 0;\n    let iretationCounter = 0;\n    const performanceStart = performance.now();\n    let performanceEnd;\n    while (true) {\n        const point = POINTS[turn];\n        const y = outputSignal(point, w1, w2);\n        if (highLowCheck(point, y, P) && outputSignalCheck(POINTS, w1, w2)) {\n            break;\n        };\n        deltaRule = +(P - y).toFixed(accuracy);\n        w1 = w(w1, deltaRule, point.x1, learningSpeed);\n        w2 = w(w2, deltaRule, point.x2, learningSpeed);\n        (turn === POINTS.length - 1) ? turn = 0 : turn++;\n        iretationCounter++;\n        if (deadlines.temporal.isUsed) {\n            performanceEnd = performance.now();\n            if ((performance.now() - performanceStart) >= (deadlines.temporal.seconds * 1000)) {\n                break;\n            };\n        };\n        if (deadlines.iterative.isUsed) {\n            if (iretationCounter >= deadlines.iterative.iterations) {\n                break;\n            };\n        };\n    };\n    const perceptronPerformanceTime = performanceEnd - performanceStart || 0;\n    return [w1, w2, perceptronPerformanceTime, iretationCounter];\n};\n\nexport default function App() {\n  const [factorizedNumber, setFactorizedNumber] = useState('');\n  const [factorizedNumberAnswer, setFactorizedNumberAnswer] = useState('');\n  return (\n    <View>\n      <Text>Fermat's Factorization Method</Text>\n      <Text>{`A  *  B  =  ${factorizedNumber || ''}`}</Text>\n      <TextInput placeholder=\"Set Number\" onChangeText={text => setFactorizedNumber(text)}></TextInput>\n      <Button title=\"Number Factorization\" onPress={() => setFactorizedNumberAnswer(fErmatFactorization(+factorizedNumber))}></Button>\n      <Text>{factorizedNumberAnswer && `A  =  ${factorizedNumberAnswer[0]};  B  =  ${factorizedNumberAnswer[1]}`}</Text>\n\n\n      <Text>Perceptron Model</Text>\n\n\n    </View>\n  );\n};\n\n\n\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n    justifyContent: 'center',\n    alignItems: 'center',\n    backgroundColor: '#F5FCFF',\n  }\n});\n"]},"metadata":{},"sourceType":"module"}